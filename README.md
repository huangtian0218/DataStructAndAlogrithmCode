# Data_Struct

## Data Struct And Algorithm C description
### stack

1. stack -- pointer

   ```
   /* stack.c
   *   1) 入栈和出栈：都是在栈顶进行操作的；
   *   2）入栈：新元素加入，分配存储空间；
   *   3）top 指向栈顶的，栈顶都是header 空指针，元素的操作都是检查第二个栈；
   *   4) 站的空间地址：由高位指向低位的
   */
   ```

2. stack -- arrray

   ```
   /*
   *   array_stack.h
   *   栈：通过数组实现
   *   1) 数组定义：定义到结构体中，定义成指针数组；
   *   2) 数组做右值的时候，自动转换成指针；数组取元素，其实也是地址取元素
   *   3)int TopOfStack; //表示数组的下标地址；int型能够自加；类似于next 
   */
   
   /*
   *   array_stack.c
   *   栈：通过数组实现
   *       除了数据的操作是通过数组的形式：下标进行访问元素
   *   1) 数组大小,通过变量传进去；和malloc 创建的内存单元
   *   2) s->TopOfStack 表示的是下标，数组下标的错误应该是负数; 判断栈数组是空的还是满的；通过下标判断
   *   3) s->array[ ++s->TopOfStack ] 通过数组的方式：进行出栈和进栈
   */
   ```

### queue

1. queue -- array

   ```
   /*
   *   array_queue.c
   *   1)判断队列是否为空、满：定义了一个标志位，有数就加1
   *   2)初始化时：q->front = 1;q->rear = 0 因为队尾rear还保存一个元素，满足出队
   */
   ```


## Tree

### tree

```
/* 
*   tree.c
*   二叉查找树：用关键字表示
*   1)find tree:查找到叶子节点，还没的话，返回NULL
*   2)find_min _max: 递归和非递归的方式进行实现；
*       非递归：考虑base基准情况
*   3) insert: 插入元素的关键字时：考虑tree是否为空；tree不为空时，元素是否已存在
*   4) delete_x: 遍历得到元素位置，还得考虑该位置包含两个child和一个child的情况。
*/
```

### tree_AVL

```
/*
*   tree_avl.c
*	1)任意节点的 左子树和右子树高度最多差1的二叉查找树
*/
```

## Hash 散列函数

```
/*
*   hashval.c 
*   1) 散列函数最好的选择；
*   2) nextprime：空间大小是素数，减小不同的key分配到同一空间
*   3) 分散链表的初始化：分配三个存储空间
*/

```

## priority queue

### binary heap

```
/* 
*    binary_heap.c
*   1) 数组实现二叉堆的存储
×   2）二叉堆的性质：任意节点的关键字都小于其后裔的关键字
*   
*/
```

### left_heap

```
/*
*   left_heap.c
*   1) 通过指针实现堆树的合并merge；
*	2) 任意节点X，左儿子的Npl >= 右儿子的Npl
*/
```

### binomial_queue

```
二项队列：二项树的合并
```



## Sword Offer

### 03_DuplicationArray

1. duplicate_array.c

   ```
   // 面试题3（一）：找出数组中重复的数字
   // 题目：在一个长度为n的数组里的所有数字都在0到n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，
   // 也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2, 3, 1, 0, 2, 5, 3}，
   // 那么对应的输出是重复的数字2或者3
   ```
   
2. duplicate_no_edit_array.c

   ```
   // 面试题3（二）：不修改数组找出重复的数字
   // 题目：在一个长度为n+1的数组里的所有数字都在1到n的范围内，所以数组中至
   // 少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的
   // 数组。例如，如果输入长度为8的数组{2, 3, 5, 4, 3, 2, 6, 7}，那么对应的
   // 输出是重复的数字2或者3。
   ```
   
3. reorder_OddEven_array.c

   ```
   // 面试题21：调整数组顺序使奇数位于偶数前面
   // 题目：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有
   // 奇数位于数组的前半部分，所有偶数位于数组的后半部分。
   ```

### 04_FindInpartialySortMatrix

1. find_in_matrix.c

   ```
   // 面试题4：二维数组中的查找
   // 题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按
   // 照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个
   // 整数，判断数组中是否含有该整数。
   ```

### 05_String

1. string_replace.c

   ```
   // 面试题5：替换空格
   // 题目：请实现一个函数，把字符串中的每个空格替换成"%20"。例如输入“We are happy.”，
   // 则输出“We%20are%20happy.”。
   ```
   
2. match_string.c

   ```
   // 面试题19：正则表达式匹配
   // 题目：请实现一个函数用来匹配包含'.'和'*'的正则表达式。
   // 模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（含0次）。
   // 在本题中，匹配是指字符串的所有字符匹配整个模式。
   // 例如，字符串"aaa"与模式"a.a"和"ab*ac*a"(b,c 选择0次)匹配，但与"aa.a"及"ab*a"均不匹配。
   ```

### 06_List

1. one_list.c

   ```
   /*
   *   题目：单链表 节点的插入和删除
   *   1) 每插入一个节点，都要为新节点分配内存；
   *   2) 删除节点，需要将其free，避免野指针；
       Parameter：
           a) **phead 头指针：定义为指向指针的指针, 防止（*root）根指针为空时，的内存地址被直接修改；
           b) 单链表：头指针是要保存数据的，和双向链表有点区别。    
   */
   ```

2. double_list.c

   ```
   /*
   *   题目：双链表 节点的插入和删除
   *   1) 双链表的插入有四种情况：
   *       a.插入到链表中间；b.插入到起始位置；  
   *       c.插入到末尾节点；d.插入到空链表中;   
   ```
   
3. print_link_form_tail_to_head.c

   ```
   // 面试题6：从尾到头打印链表
   // 题目：输入一个链表的头结点，从尾到头反过来打印出每个结点的值。
   ```

4. callback_use.c

   ```
   // 回调函数的应用:在一个单链表中查找一个指定值的函数。它的参数是一个指向链表第一个节点的指针，
   // 一个指向我们需要查找的值的指针和一个函数指针，它所指向的函数用于比较存储于链表中的类型的值
   ```

5. delete_oneListNode.c

   ```
   // 面试题18（一）：在O(1)时间删除链表结点
   // 题目：给定单向链表的头指针和一个结点指针，定义一个函数在O(1)时间删除该结点。
   ```

6. delete_repeatNode.c

   ```
   // 面试题18（二）：删除链表中重复的结点
   // 题目：在一个排序的链表中，如何删除重复的结点？将重复的节点全部删除，只保留不重复的
   // 5-7-9-9-11;  -->  5-7-11
   ```

7. FIndKth_ToTail.c

   ```
   // 面试题22：链表中倒数第k个结点
   // 题目：输入一个链表，输出该链表中倒数第k个结点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾结点是倒数第1个结点。
   // 例如一个链表有6个结点，从头结点开始它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个结点是值为4的结点。
   ```

8. EnterNode_LoopList.c

   ```
   // 面试题23：链表中环的入口结点
   // 题目：一个链表中包含环，如何找出环的入口结点？
   ```

9. reverseList.c

   ```
   // // 面试题24：反转链表
   // 题目一：定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。
   // 题目二：定义一个函数，输入一个链表头结点，从链表中的第 k 个节点到 m个位置进行反转，返回反转链表的头结点；
   //题目扩展三：将链表前面k个节点进行反转； 用题目二的思路
   ```
   
10. reverseList_FromTailH.c

    ```
    // 面试题24(四)：反转链表，从链表的倒数第 H 个节点进行反转
    // 为了方便：链表指针都从第一个节点开始计数为1
    ​```
    ```

11. merge_orderList.c

    ```
    // // 面试题25：合并两个排序的链表
    // 题目：输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。
    // 例如: list_one: 1-3-5-7; list_two: 2-4-6-8; 
    // 链表合并之后：1-2-3-4-5-6-7-8; 
    ```

### 07_tree

1. construct_binary_tree.c

   ```
   // 面试题7：重建二叉树
   // 题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
   //例如输入前序遍历序列{1, 2, 4, 7, 3, 5, 6, 8}和中序遍历序列{4, 7, 2, 1, 5, 3, 8, 6}，则重建出二叉树并输出它的头结点。
   ```
   
2. next_binary_tree_node.c

   ```
   // 面试题8：二叉树的下一个结点
   // 题目：给定一棵二叉树和其中的一个结点，如何找出中序遍历顺序的下一个结点？
   // 树中的结点除了有两个分别指向左右子结点的指针以外，还有一个指向父结点的指针。
   ```
   

### 08_stack 的实现

 1. 函数接口

    ```
    1. 堆栈接口实现：在函数中以存根的形式存在，便于从一种形式转换为另外一种形式；
      - 静态数组：结构长度固定
      - 动态分配的数组结构：重新构建一个数组，复制原先数组到新数组，并删除原先数组
      - 动态分配的链式结构：每个元素单独分配内存空间
    2. 函数接口：
     push: 数组下标加1，存入元素
     pop: 数组下标减一；
     top：返回此时下标的数组元素
        编写Makefile 的时候，只需要加上对应的 .c 文件就行，接口文件不用变
    ```

### 08_queue

1. 函数接口

   ```
   * 1. 队列的接口：
       insert()：队列的插入函数，相当于入队；
       delete_m(): 删除元素，想当于出队；
       first():    返回队列的第一个元素
   
   1.静态数组实现循环队列麻烦之处：
           a. 判断何时达到队列循环的条件：(rear = (rear+1) % QUEUE_SIZE)
           b. 判断何时为空，何时为满
               数组中有一个位置空着不用；
               (rear+1) % QUEUE_SIZE == front      队列为空
               (rear+2) %  QUEUE_SIZE == front     队列为满
           c. a % b :  if(a<b),那么输出的直接是元素a
   ```


### 09_recursion_and_loop

1. fibonacci.c

   ```
   // 面试题：斐波那契数列，青蛙跳台阶
   // 题目：写一个函数，输入n，求斐波那契（Fibonacci）数列的第n项。
   ```

### 10_find_and_sort

1. quick_sort.c

   ```
   // 快速排序算法的实现
   /*
   *   1. 快速排序算法： 
           通过枢纽元将数组元素分为两部分；a [left] = { x < v }；a[center] = {v} ; a[right] = { x > v }；
           对每一部分再次执行快速排序，最后排序；
       2. 函数功能
           partition   根据枢纽元素：划分数组为两部分
           quick_sort  递归实现 快速排序，并且完成两部分的排序
   */
   ```

2. rotating_array.c

   ```
   // 面试题11：旋转数组的最小数字
   // 题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
   // 输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如数组
   // {3, 4, 5, 1, 2}为{1, 2, 3, 4, 5}的一个旋转，该数组的最小值为1。
   ```

### 11_backtracking

1. matrix_path.c

   ```
   // // 面试题12：矩阵中的路径
   // 题目：请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中任意一格开始，每一步可以在矩阵中向左、右、// 上、下移动一格。
   // 如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字// 母用下划线标出）。
   // 但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。
   ```

2. moving_count.c

   ```
   // 面试题13：机器人的运动范围
   // 题目：地上有一个m行n列的方格。一个机器人从坐标(0, 0)的格子开始移动，它// 每一次可以向左、右、上、下移动一格，
   // 但不能进入行坐标和列坐标的数位之和大于k的格子。
   // 例如，当k为18时，机器人能够进入方格(35, 37)，因为3+5+3+7=18。但它不能进入方格(35, 38)，因为3+5+3+8=19。请问该机器人能够到达多少个格子？
   ```

### 12_DynamicProgramming_GreedyAlogithm

1. Dynamic_maxProduct.c

   ```
   // 面试题14：剪绳子 :给你一根长度为n绳子，请把绳子剪成m段（m、n都是整数，n>1并且m≥1）。
   // 每段的绳子的长度记为k[0]、k[1]、……、k[m]。k[0]*k[1]*…*k[m]可能的最大乘积是多少？
   // 例如当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到最大的乘积18。
   ```

2. Greedy_maxProduct.c

   ```
   //  题目： 剪绳子：通过贪婪算法实现；
   ```

### 13_bit_opreation

1. one_count.c

   ```
   //  面试题15：二进制中1的个数
   // 题目：请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。例如
   // 把9表示成二进制是1001，有2位是1。因此如果输入9，该函数输出2。
   
   ```


### 14_CodeQuality_Integrity

1. math_funcation_pow.c

   ```
   // 面试题16：数值的整数次方
   // 题目：实现函数double Power(double base, int exponent)，求base的exponent次方。
   // 不得使用库函数，同时不需要考虑大数问题。
   ```

2. print_oneToMaxBit_number.c

   ```
   // 面试题17：打印1到最大的n位数
   // 题目：输入数字n，按顺序打印出从1最大的n位十进制数。比如输入3，则打印出1、2、3一直到最大的3位数即999。
   相当于考察数据结构[字符串]，算法实现[递归和循环]
   ```

   