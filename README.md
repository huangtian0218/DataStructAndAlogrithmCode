# Data_Struct

## Data Struct And Algorithm C description
### Link_list

1. link_list  --  pointer

   ```
   /* link_list */
   /* 定义了位置和链表的结构体指针 */
   /* 头文件也可用在数组的实现中 */
   
   /*link_list.c 
   *   1) 结构体数组中的数据在链表中怎么存储；
   *       是不是只能一个个的读入
   *   2) 指针结构体：定义了一个position 和 list 的结构体
   *   3)malloc(sizeof(struct node))创建元素的存储空间；如果是			  malloc(sizeof(pointer) 只是指针的存储空间
   *   4)删除整个链表,释放链表的每一个元素,将List 置Null；此时定义另外一个指针完成  每个元素释放的工作
   */
   ```

2. link_list  --  array

   ```
    /* cursor.h */
    /* 链表游标实现的方法 */
   
   /* cursor.c 
   *   1)链表的游标实现;
   *   2) 指针的空用NULL; 数组的空用0
   *   3) 数组中的链表：作为下标使用
   */
   ```

### stack

1. stack -- pointer

   ```
   /* stack.c
   *   1) 入栈和出栈：都是在栈顶进行操作的；
   *   2）入栈：新元素加入，分配存储空间；
   *   3）top 指向栈顶的，栈顶都是header 空指针，元素的操作都是检查第二个栈；
   *   4) 站的空间地址：由高位指向低位的
   */
   ```

2. stack -- arrray

   ```
   /*
   *   array_stack.h
   *   栈：通过数组实现
   *   1) 数组定义：定义到结构体中，定义成指针数组；
   *   2) 数组做右值的时候，自动转换成指针；数组取元素，其实也是地址取元素
   *   3)int TopOfStack; //表示数组的下标地址；int型能够自加；类似于next 
   */
   
   /*
   *   array_stack.c
   *   栈：通过数组实现
   *       除了数据的操作是通过数组的形式：下标进行访问元素
   *   1) 数组大小,通过变量传进去；和malloc 创建的内存单元
   *   2) s->TopOfStack 表示的是下标，数组下标的错误应该是负数; 判断栈数组是空的还是满的；通过下标判断
   *   3) s->array[ ++s->TopOfStack ] 通过数组的方式：进行出栈和进栈
   */
   ```

### queue

1. queue -- array

   ```
   /*
   *   array_queue.c
   *   1)判断队列是否为空、满：定义了一个标志位，有数就加1
   *   2)初始化时：q->front = 1;q->rear = 0 因为队尾rear还保存一个元素，满足出队
   */
   ```


## Tree

### tree

```
/* 
*   tree.c
*   二叉查找树：用关键字表示
*   1)find tree:查找到叶子节点，还没的话，返回NULL
*   2)find_min _max: 递归和非递归的方式进行实现；
*       非递归：考虑base基准情况
*   3) insert: 插入元素的关键字时：考虑tree是否为空；tree不为空时，元素是否已存在
*   4) delete_x: 遍历得到元素位置，还得考虑该位置包含两个child和一个child的情况。
*/
```

### tree_AVL

```
/*
*   tree_avl.c
*	1)任意节点的 左子树和右子树高度最多差1的二叉查找树
*/
```

## Hash 散列函数

```
/*
*   hashval.c 
*   1) 散列函数最好的选择；
*   2) nextprime：空间大小是素数，减小不同的key分配到同一空间
*   3) 分散链表的初始化：分配三个存储空间
*/

```

## priority queue

### binary heap

```
/* 
*    binary_heap.c
*   1) 数组实现二叉堆的存储
×   2）二叉堆的性质：任意节点的关键字都小于其后裔的关键字
*   
*/
```

### left_heap

```
/*
*   left_heap.c
*   1) 通过指针实现堆树的合并merge；
*	2) 任意节点X，左儿子的Npl >= 右儿子的Npl
*/
```

### binomial_queue

```
二项队列：二项树的合并
```



## Sword Offer

### 03_DuplicationArray

1. duplicate_array.c

   ```
   // 面试题3（一）：找出数组中重复的数字
   // 题目：在一个长度为n的数组里的所有数字都在0到n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，
   // 也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2, 3, 1, 0, 2, 5, 3}，
   // 那么对应的输出是重复的数字2或者3
   ```
   
2. duplicate_no_edit_array.c

   ```
   // 面试题3（二）：不修改数组找出重复的数字
   // 题目：在一个长度为n+1的数组里的所有数字都在1到n的范围内，所以数组中至
   // 少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的
   // 数组。例如，如果输入长度为8的数组{2, 3, 5, 4, 3, 2, 6, 7}，那么对应的
   // 输出是重复的数字2或者3。
   ```

### 04_FindInpartialySortMatrix

1. find_in_matrix.c

   ```
   // 面试题4：二维数组中的查找
   // 题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按
   // 照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个
   // 整数，判断数组中是否含有该整数。
   ```

### 05_ReplaceSpaces

1. string_replace.c

   ```
   // 面试题5：替换空格
   // 题目：请实现一个函数，把字符串中的每个空格替换成"%20"。例如输入“We are happy.”，
   // 则输出“We%20are%20happy.”。
   ```

### 06_List

1. one_list.c

   ```
   /*
   *   题目：单链表 节点的插入和删除
   *   1) 每插入一个节点，都要为新节点分配内存；
   *   2) 删除节点，需要将其free，避免野指针；
       Parameter：
           a) **phead 头指针：定义为指向指针的指针, 防止（*root）根指针为空时，的内存地址被直接修改；
           b) 单链表：头指针是要保存数据的，和双向链表有点区别。    
   */
   ```

2. double_list.c

   ```
   /*
   *   题目：双链表 节点的插入和删除
   *   1) 双链表的插入有四种情况：
   *       a.插入到链表中间；b.插入到起始位置；  
   *       c.插入到末尾节点；d.插入到空链表中;   
   ```
   
3. print_link_form_tail_to_head.c

   ```
   // 面试题6：从尾到头打印链表
   // 题目：输入一个链表的头结点，从尾到头反过来打印出每个结点的值。
   ```

### 07_tree

1. construct_binary_tree.c

   ```
   // 面试题7：重建二叉树
   // 题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
   //例如输入前序遍历序列{1, 2, 4, 7, 3, 5, 6, 8}和中序遍历序列{4, 7, 2, 1, 5, 3, 8, 6}，则重建出二叉树并输出它的头结点。
   ```
   
2. next_binary_tree_node.c

   ```
   // 面试题8：二叉树的下一个结点
   // 题目：给定一棵二叉树和其中的一个结点，如何找出中序遍历顺序的下一个结点？
   // 树中的结点除了有两个分别指向左右子结点的指针以外，还有一个指向父结点的指针。
   ```
   

### 08_stack 的实现

 1. 函数接口

    ```
    1. 堆栈接口实现：在函数中以存根的形式存在，便于从一种形式转换为另外一种形式；
      - 静态数组：结构长度固定
      - 动态分配的数组结构：重新构建一个数组，复制原先数组到新数组，并删除原先数组
      - 动态分配的链式结构：每个元素单独分配内存空间
    2. 函数接口：
     push: 数组下标加1，存入元素
     pop: 数组下标减一；
     top：返回此时下标的数组元素
        编写Makefile 的时候，只需要加上对应的 .c 文件就行，接口文件不用变
    ```

### 08_queue

1. 函数接口

   ```
   * 1. 队列的接口：
       insert()：队列的插入函数，相当于入队；
       delete_m(): 删除元素，想当于出队；
       first():    返回队列的第一个元素
   
   1.静态数组实现循环队列麻烦之处：
           a. 判断何时达到队列循环的条件：(rear = (rear+1) % QUEUE_SIZE)
           b. 判断何时为空，何时为满
               数组中有一个位置空着不用；
               (rear+1) % QUEUE_SIZE == front      队列为空
               (rear+2) %  QUEUE_SIZE == front     队列为满
           c. a % b :  if(a<b),那么输出的直接是元素a
   ```

   